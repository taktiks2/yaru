---
description: 未ステージング変更を適切な粒度で分析し、段階的にコミットする
argument-hint: なし
allowed-tools: Bash(git:*), Bash(cog:*), Read, AskUserQuestion
---

# スマートコミットコマンド

未ステージングの変更を分析し、適切な粒度でグループ化して、cocogitto（Conventional Commits）形式でコミットを作成します。

**重要**: このプロジェクトはcocogittoを使用しており、コミットメッセージは自動的に`cog.toml`で定義されたルールで検証されます。

## 手順

### 1. 現在の状態確認

以下のコマンドを実行して現在の状態を把握：

```bash
git status
git diff --stat
git diff
```

- 変更がない場合: 「コミットする変更がありません」と表示して終了
- 変更がある場合: 次のステップへ

### 2. 変更の分析とグループ化

変更内容を分析し、以下の基準で適切にグループ化：

1. **変更の種類で分類**（`cog.toml`で定義されたコミットタイプに従う）：
   - 新機能の追加 → `feat:`
   - バグ修正 → `fix:`
   - ドキュメントの変更 → `docs:`
   - コードの意味に影響しない変更（フォーマットなど） → `style:`
   - リファクタリング → `refactor:`
   - パフォーマンス改善 → `perf:`
   - テストの追加・修正 → `test:`
   - ビルドプロセスやツールの変更 → `chore:`
   - CI設定の変更 → `ci:`
   - ビルドシステムの変更 → `build:`

2. **変更の関連性で分類**：
   - 同じ機能に関する変更
   - 同じモジュール/ファイルに関する変更
   - 同じ目的を持つ変更

3. **適切な粒度**：
   - 1つのコミットは1つの論理的な変更を表す
   - 大きすぎず、小さすぎない単位
   - レビューしやすい大きさ

### 3. コミットメッセージの生成

各グループに対して、以下の形式でメッセージを生成：

```
<type>: <簡潔な説明>
```

**コミットメッセージのルール**：
- 日本語で記述
- 簡潔で明確（50文字以内を目標）
- 何を変更したかではなく、何のために変更したかを記述
- 例:
  - ✅ `feat: showコマンドの実装を追加`
  - ✅ `refactor: create_single_*_table関数をcreate_*_detail_table関数に統一`
  - ✅ `test: タスクコマンドの包括的なテストを追加`
  - ❌ `update: いろいろ修正`
  - ❌ `fix: bug`

### 4. Cocogitto検証の確認

コミット実行前に、メッセージがcocogittoのルールに準拠しているか確認：

```bash
# コミットメッセージの検証（オプション）
echo "<type>: <message>" | cog verify --from-stdin
```

### 5. コミットの実行

以下を実行：

```bash
# 対象ファイルをステージング
git add <file1> <file2> ...

# コミット作成（cocogittoのcommit-msgフックが自動検証）
git commit -m "<type>: <message>"
```

**注意**:
- コミットメッセージは`.git/hooks/commit-msg`フックで自動検証されます
- `cog.toml`で定義されていないコミットタイプは拒否されます
- 検証失敗時は適切なエラーメッセージが表示されます

### 6. 完了報告

すべてのコミット処理が完了したら：
- 作成されたコミット数を報告
- スキップされたファイルがあれば表示
- `git log --oneline -n <作成数>` で作成されたコミットを表示

## 重要な注意事項

1. **テストファイルとプロダクションコードの分離**：
   - テストの追加/修正は別コミット（`test:`）
   - 実装とテストを一緒にコミットしない（TDD原則に従う）

2. **コミットの原子性**：
   - 各コミットは独立して意味を持つ
   - ビルドが通る状態を保つ

3. **コミット前の確認**：
   - デバッグコードが含まれていないか確認
   - コメントアウトされた不要なコードがないか確認
   - フォーマットが適切か確認（必要に応じて `cargo fmt` を実行）
   - コミットメッセージが`cog.toml`で定義されたルールに準拠しているか確認

4. **機密情報のチェック**：
   - パスワード、APIキー、トークンなどが含まれていないか確認
   - 含まれている場合は警告を表示し、コミットを中止

5. **大量の変更への対応**：
   - 変更ファイルが10個を超える場合は警告を表示
   - グループ化の方針をユーザーに確認

## 使用例

```bash
# 基本的な使用
/smart-commit
```

## 典型的なシナリオ

### シナリオ1: TDDでテストと実装を分離

```
変更ファイル:
- src/commands/show.rs (新規)
- tests/commands/show_test.rs (新規)

→ 2つのコミットに分割：
  1. test: showコマンドのテストを追加
  2. feat: showコマンドの実装を追加
```

### シナリオ2: リファクタリングと機能追加

```
変更ファイル:
- src/display.rs (リファクタリング)
- src/commands/list.rs (新機能)

→ 2つのコミットに分割：
  1. refactor: テーブル表示処理を抽象化
  2. feat: リスト表示にフィルタ機能を追加
```

### シナリオ3: 関連する複数ファイルの変更

```
変更ファイル:
- src/cli.rs (showサブコマンド追加)
- src/lib.rs (ハンドラー追加)
- src/commands/show.rs (実装追加)

→ 1つのコミット：
  feat: showコマンドの実装を追加
```

## エラーハンドリング

- git コマンドが失敗した場合: エラーメッセージを表示し、処理を中止
- マージコンフリクトがある場合: 先に解決するよう促す
- リベース中の場合: リベースを完了してから実行するよう促す
- cocogitto検証失敗の場合: エラーメッセージを表示し、メッセージの修正を促す
  - 例: `❌ コミットメッセージがConventional Commitsの形式に従っていません。`
  - 利用可能なコミットタイプの一覧を表示
  - 正しい形式の例を提示

## Cocogittoについて

このプロジェクトでは、コミットメッセージの品質を保つためにcocogittoを使用しています：

- **自動検証**: `git commit`時に`.git/hooks/commit-msg`フックが自動実行
- **ルール定義**: `cog.toml`でコミットタイプとCHANGELOG生成ルールを定義
- **バージョン管理**: `cog bump`でセマンティックバージョニングに基づく自動バージョンアップ
- **CHANGELOG生成**: コミット履歴から自動的にCHANGELOGを生成

詳細は`cog.toml`を参照してください。
